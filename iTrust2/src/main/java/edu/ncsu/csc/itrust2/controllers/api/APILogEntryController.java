package edu.ncsu.csc.itrust2.controllers.api;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Locale;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

import edu.ncsu.csc.itrust2.models.persistent.LogEntry;
import edu.ncsu.csc.itrust2.models.persistent.User;
import edu.ncsu.csc.itrust2.utils.LoggerUtil;

/**
 * REST controller for interacting with Log Entry-related endpoints This will
 * have somewhat reduced functionality compared to the other controllers because
 * we don't want users to be able to delete logged events (_even_ if they are
 * Personnel/an admin)
 *
 * @author Kai Presler-Marshall
 *
 */
@RestController
@SuppressWarnings ( { "unchecked", "rawtypes" } )
public class APILogEntryController extends APIController {

    /**
     * Retrieves and returns a List of all LogEntries in the system
     *
     * @return list of log entries
     */
    @GetMapping ( BASE_PATH + "/logentries" )
    public List<LogEntry> getLogEntries () {
        return LogEntry.getLogEntries();
    }

    /**
     * Retrieves and returns a specific log entry specified by the id provided.
     *
     * @param id
     *            The id of the log entry, as generated by Hibernate and used as
     *            the primary key
     * @return response
     */
    @GetMapping ( BASE_PATH + "/logentries/{id}" )
    public ResponseEntity getEntry ( @PathVariable ( "id" ) final Long id ) {
        final LogEntry entry = LogEntry.getById( id );
        return null == entry
                ? new ResponseEntity( errorResponse( "No log entry found for id " + id ), HttpStatus.NOT_FOUND )
                : new ResponseEntity( entry, HttpStatus.OK );
    }

    /**
     * Returns a list of log entries for the logged in patient
     *
     * @return List of Entry for the patient
     */
    @GetMapping ( BASE_PATH + "/logentriesforcurrentuser" )
    public List<LogEntry> getLogEntriesforCurrentUser () {
        final User self = User.getByName( SecurityContextHolder.getContext().getAuthentication().getName() );
        if ( self == null ) {
            return null;
        }
        final String id = SecurityContextHolder.getContext().getAuthentication().getName();
        final List<LogEntry> all = LogEntry.getAllForUser( id );
        for ( int i = 0; i < all.size(); i++ ) {
            all.get( i ).role = self.getRole().toString();
        }
        return all;
    }

    /**
     * Returns a list of log entries for the logged in patient
     *
     * @param sy
     *            start year
     * @param sm
     *            start month
     * @param sd
     *            start day
     * @param ey
     *            end year
     * @param em
     *            end month
     * @param ed
     *            end day
     * @return ResponseEntity of the List<LogEntry> for the access logs in
     *         period.
     */
    @SuppressWarnings ( "deprecation" )
    @GetMapping ( BASE_PATH + "/logentriesfordate/{startYear}/{startMonth}/{startDay}/{endYear}/{endMonth}/{endDay}" )
    public ResponseEntity getLogEntriesforDate ( @PathVariable ( "startYear" ) final int sy,
            @PathVariable ( "startMonth" ) final int sm, @PathVariable ( "startDay" ) final int sd,
            @PathVariable ( "endYear" ) final int ey, @PathVariable ( "endMonth" ) final int em,
            @PathVariable ( "endDay" ) final int ed ) {

        final List<LogEntry> result = new ArrayList<LogEntry>();
        try {
            final String startdate = sy + "/" + sm + "/" + sd;
            final String enddate = ey + "/" + em + "/" + ed;
            // date format
            final DateFormat format1 = new SimpleDateFormat( "yyyy/MM/dd", Locale.ENGLISH );
            // validate the date, will throw exception if date string is invalid
            // date
            format1.setLenient( false );
            final Date start = format1.parse( startdate );
            final Date end = format1.parse( enddate );
            end.setHours( 23 );
            end.setMinutes( 59 );
            end.setSeconds( 59 );
            // if start date comes after end date, throw exception
            if ( start.after( end ) ) {
                throw new IllegalArgumentException( "start data is after end date" );
            }
            final User self = User.getByName( SecurityContextHolder.getContext().getAuthentication().getName() );
            if ( self == null ) {
                return null;
            }
            final String id = SecurityContextHolder.getContext().getAuthentication().getName();
            final List<LogEntry> all = LogEntry.getAllForUser( id );
            for ( int i = 0; i < all.size(); i++ ) {
                if ( all.get( i ).getTime().getTime().after( start )
                        && all.get( i ).getTime().getTime().before( end ) ) {
                    all.get( i ).role = self.getRole().toString();
                    result.add( all.get( i ) );
                }
            }
            return new ResponseEntity( result, HttpStatus.OK );
        }
        catch ( final Exception e ) {
            return new ResponseEntity( errorResponse( e.getMessage() ), HttpStatus.INTERNAL_SERVER_ERROR );
        }
    }

    /**
     * Returns a list of log entries for the logged in patient
     *
     * @return List of Entry for the patient
     */
    @GetMapping ( BASE_PATH + "/toplogentriesforcurrentuser" )
    public List<LogEntry> getTopLogEntriesforCurrentUser () {
        final User self = User.getByName( SecurityContextHolder.getContext().getAuthentication().getName() );
        if ( self == null ) {
            return null;
        }
        final String id = SecurityContextHolder.getContext().getAuthentication().getName();
        final List<LogEntry> all = LoggerUtil.getRecentTopForUser( id, 10 );
        for ( int i = 0; i < all.size(); i++ ) {
            all.get( i ).role = self.getRole().toString();
        }
        return all;
    }
}
